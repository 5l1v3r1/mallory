package mallory

import (
	"errors"
	"flag"
	"os"
	"path"
)

const (
	CO_RED    = "\033[0;31;49m"
	CO_GREEN  = "\033[0;32;49m"
	CO_YELLOW = "\033[0;33;49m"
	CO_BLUE   = "\033[0;34;49m"
	CO_RESET  = "\033[0m"
)

// Provide global config for mallory
type Env struct {
	// work space, default is $HOME/.mallory
	Work string
	// local addr to listen and serve, default is 127.0.0.1:1315
	Addr string
	// remote engine to be used, "direct"(default), "gae", "socks", or "ssh"
	Engine string
	// 1) GAE application URL, only valid when the engine is "gae"
	//    e.g. https://kill-me-baby.appspot.com
	// 2) URL of socks proxy, only valid when the engine is "socks"
	//    e.g. socks5://localhost:1314
	// 3) URL of ssh server, only valid when the engine is "ssh"
	//    e.g. ssh://user:passwd@192.168.1.1:1122
	Remote string
	// > http://www.akadia.com/services/ssh_test_certificate.html
	// > http://mitmproxy.org/doc/ssl.html
	// RSA private key file and self-signed root certificate file
	// Can be generated by OpenSSL:
	// - RSA private key file, without input any extra info
	//      openssl genrsa -out mallory.key 2048
	// - Self-signed root certificate file, need input some X.509 attributes
	//   such as Country Name, Comman Name etc.
	//      openssl req -new -x509 -days 365 -key mollory.key -out mallory.crt
	Key  string // mallory.key, only valid when engine is "gae"
	Cert string // mallory.crt, only valid when engine is "gae"
	// pac file path
	PAC string
	// terminal helper, test the default logger(os.Stderr) is terminal or not
	Istty bool
}

// Prepare flags and env
func (self *Env) Parse() error {
	flag.StringVar(&self.Addr, "addr", "127.0.0.1:1315", "mallory server address")
	flag.StringVar(&self.Engine, "engine", "direct", `mallory engine, "direct", "gae", "socks" or "ssh"`)
	flag.StringVar(&self.Remote, "remote", "", "remote server address for different engines")
	flag.StringVar(&self.Work, "work", path.Join("$HOME", ".mallory"), "working directory for mallory")

	flag.Parse()

	if self.Engine != "direct" && self.Engine != "gae" && self.Engine != "socks" && self.Engine != "ssh" {
		return errors.New(`engine should be "direct", "gae", "socks" or "ssh"`)
	}

	// expand env vars for paths
	self.Work = os.ExpandEnv(self.Work)
	self.Key = path.Join(self.Work, "mallory.key")
	self.Cert = path.Join(self.Work, "mallory.crt")
	self.PAC = path.Join(self.Work, "mallory.pac")

	self.Istty = Isatty(os.Stderr)
	return nil
}
